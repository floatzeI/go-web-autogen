package main

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"regexp"
	"strings"
	"time"
	"web-autogen/decoratorparser"
)

var fileHeader = `// Package autogen_web
// This file was automatically generated by go-web-autogen
// It should not be edited manually
`

func main() {
	// types map
	var typeToMethodMap = make(map[string]string)
	typeToMethodMap["int"] = "GetInt"
	typeToMethodMap["int64"] = "GetInt64"
	typeToMethodMap["uint"] = "GetUint"
	typeToMethodMap["uint64"] = "GetUint64"
	typeToMethodMap["string"] = "GetString"

	var currentTime = time.Now()
	fileHeader += "// Generated At: " + currentTime.Format(time.RFC3339) + "\n"
	var functionNameRegex = regexp.MustCompile("[^a-zA-Z0-9]")
	var numberRegex = regexp.MustCompile("[0-9]")
	var packageNameRegex = regexp.MustCompile("package ([a-zA-Z_]+)")
	var controllerMethods = make([]string, 0)
	var controllerMethodDefinitiions = make([]string, 0)

	target := "examples/project-one/"
	targetFile := target + "controllers/example.go"
	var rawFile, readErr = os.ReadFile(targetFile)
	if readErr != nil {
		log.Fatal(readErr)
	}
	var rawFileStr = string(rawFile)
	var packageName = packageNameRegex.FindAllStringSubmatch(rawFileStr, -1)[0][1]
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "", rawFile, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	for _, f := range node.Decls {
		var autogenComments = make([]string, 0)
		// var autogenBody = make([]string, 0)

		fn, ok := f.(*ast.FuncDecl)
		if !ok {
			continue
		}
		var parametersList = make([]string, 0)
		var comments = fn.Doc.Text()
		var functionCalls = decoratorparser.GetFunctions(comments)
		var _requiredCalls = functionCalls.GetCallsByName("Required")
		var requiredParams = make([]string, 0)
		for _, item := range _requiredCalls {
			for _, p := range item.Arguments {
				requiredParams = append(requiredParams, p)
			}
		}
		// add defaults
		autogenComments = append(autogenComments, "@Produce json")
		var httpMethod = decoratorparser.ParseMethod(functionCalls)
		var stringHttpMethod = decoratorparser.StringifyMethod(httpMethod)
		autogenComments = append(autogenComments, stringHttpMethod.Comment)
		var possibleResponses = decoratorparser.ParseResponse(comments)

		var hasSuccess = false
		for _, resp := range possibleResponses {
			if resp.StatusCode >= 200 && resp.StatusCode <= 299 {
				hasSuccess = true
			}
			if resp.Model == "" {
				continue
			}
			asString := decoratorparser.StringifyResponse(resp)
			autogenComments = append(autogenComments, asString)
		}
		var returns decoratorparser.ReturnType
		if !hasSuccess {
			var returnType = fn.Type.Results
			if returnType == nil {

			} else {
				// return type for basic type: "int"
				// return type for struct: "&{usersmodels GetUserById}"
				// return type for struct slice: ""
				switch xv := returnType.List[0].Type.(type) {
				case *ast.ArrayType:
					{
						var arrayType = xv.Elt
						var isSlice = xv.Len == nil
						// get the type
						var elementResult = decoratorparser.ParseReturnType(fmt.Sprintf("%v", arrayType))
						if isSlice {
							elementResult.Prefix = "[]"
							returns = elementResult
						} else {
							// todo
							panic("Array support is not yet implemented")
						}
						break
					}
				default:
					var str = fmt.Sprintf("%v", returnType.List[0].Type)
					returns = decoratorparser.ParseReturnType(str)
				}
			}

			var respToAdd = decoratorparser.StringifyResponse(decoratorparser.ResponseEntry{
				StatusCode: 200,
				Model:      returns.Prefix + "" + returns.ImportedPackage + "." + returns.Type,
			})
			autogenComments = append(autogenComments, respToAdd)
		}
		fmt.Println("required", requiredParams)
		for _, param := range fn.Type.Params.List {
			var n = param.Names[0].Name
			var t = param.Type
			// check if exists in url
			var inUrl = strings.Contains(httpMethod.Url, "{"+n+"}")
			typeAsString := fmt.Sprintf("%v", t)
			var method = typeToMethodMap[typeAsString]
			var required = "false"
			for _, item := range requiredParams {
				if item == n {
					required = "true"
				}
			}
			var pType = "query"
			if inUrl {
				pType = "path"
			}
			parametersList = append(parametersList, `NewArgumentParser(c, "`+pType+`", "`+n+`", `+required+`).`+method+`()`)
			autogenComments = append(autogenComments, `@Param `+n+` `+pType+` `+typeAsString+` `+required+` "The `+n+`"`)
		}
		for i := range autogenComments {
			autogenComments[i] = "// " + autogenComments[i]
		}
		var functionName = functionNameRegex.ReplaceAllString(httpMethod.Url, "")
		functionName = httpMethod.HttpMethod + "_" + functionName
		for numberRegex.MatchString(functionName[0:1]) {
			functionName = functionName[1:]
		}
		functionName = strings.ToLower(functionName)
		if len(functionName) == 0 {
			panic(errors.New("bad function name"))
		}
		var template = strings.Join(autogenComments, "\n") + `
func ` + functionName + `(app *fiber.App) {
	app.` + httpMethod.HttpMethod + `("` + httpMethod.Url + `", func (c *fiber.Ctx) error {
		var result = ` + packageName + "." + fn.Name.Name + `(` + strings.Join(parametersList, ",") + `)
		return c.JSON(result)
	})
}`
		controllerMethodDefinitiions = append(controllerMethodDefinitiions, template)
		controllerMethods = append(controllerMethods, functionName)
	}

	var autogenFile = fileHeader
	var autogenBytes, autogenErr = os.ReadFile("./templates/autogen_web/autogen_web.go")
	if autogenErr != nil {
		log.Fatal(autogenErr)
	}
	autogenFile += string(autogenBytes)
	var regStr = ""
	for _, str := range controllerMethods {
		regStr += str + "(app)\n"
	}
	var defStr = ""
	for _, str := range controllerMethodDefinitiions {
		defStr += str + "\n"
	}
	// templates
	autogenFile = strings.ReplaceAll(autogenFile, "	// [StartupRegistrations]", regStr)
	autogenFile = strings.ReplaceAll(autogenFile, "// [FunctionRegistrations]", defStr)
	autogenFile = strings.ReplaceAll(autogenFile, "	// [ImportRegistrations]", `	"project-one/controllers"`)
	writeTestErr := os.WriteFile(target+"/autogen/autogen_web.go", []byte(autogenFile), 0666)
	if writeTestErr != nil {
		log.Fatal(writeTestErr)
	}
	// add runtime code
	runtimeLibBytes, runtimeBytesErr := os.ReadFile("./templates/autogen_web/autogen_web_lib.go")
	if runtimeBytesErr != nil {
		log.Fatal(runtimeBytesErr)
	}
	writeFileErr := os.WriteFile(target+"/autogen/autogen_web_lib.go", runtimeLibBytes, 0666)
	if writeFileErr != nil {
		log.Fatal(writeFileErr)
	}
	// we're done!
}
